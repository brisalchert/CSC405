<!DOCTYPE html>
<html>
    <head>
        <title>Interactive Viewer</title>
        <link rel="stylesheet" href="style.css">
        <script id="vertex-shader" type="x-shader/x-vertex">
            attribute vec4 vPosition;
            attribute vec3 vNormal;
            attribute vec2 vTextureCoord;
            varying vec3 transformedNormal;
            varying vec3 fPosition;
            varying vec2 fTextureCoord;
            varying vec3 fLightPosition;

            uniform vec4 uLightPosition;
            uniform mat4 uModelViewMatrix;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uNormalMatrix;

            void main() {
                // Apply transformation/projection. The model view matrix positions
                // objects to create the illusion of a change in the position and
                // orientation of the camera. The projection matrix applies either
                // orthogonal or perspective projection to the object and converts
                // the viewing volume (originally in camera coordinates) to the
                // corresponding clip coordinates.

                vec4 transformedPosition = uModelViewMatrix * vPosition;
                gl_Position = uProjectionMatrix * transformedPosition;

                // Pass texture and normal information to the fragment shader
                fPosition = vec3(transformedPosition) / transformedPosition.w;
                transformedNormal = vec3(uNormalMatrix * vec4(vNormal, 0.0));
                fTextureCoord = vTextureCoord;

                fLightPosition = vec3(uModelViewMatrix * uLightPosition);
            }
        </script>
        <script id="fragment-shader" type="x-shader/x-fragment">
            precision mediump float;
            varying vec3 transformedNormal;
            varying vec3 fPosition;
            varying vec2 fTextureCoord;
            varying vec3 fLightPosition;

            uniform sampler2D uSampler;
            uniform float uColorTheta;

            void main() {
                float pi = (22.0 / 7.0);
                float offset = (2.0 * pi / 3.0);

                vec3 textureColor = vec3(texture2D(uSampler, fTextureCoord));

                // Compute new color value from old color value, applying a rotation
                // about the color wheel to achieve a cyclical rainbow
                float r = sin((textureColor.x * pi) + uColorTheta) / 2.0 + 0.5;
                float g = sin((textureColor.y * pi) + uColorTheta + offset) / 2.0 + 0.5;
                float b = sin((textureColor.z * pi) + uColorTheta + (2.0 * offset)) / 2.0 + 0.5;

                // Set diffuse, ambient, and specular colors, as well as shininess.
                // Ambient light permeates the scene, applying to every surface. Diffuse
                // reflections are identical across a polygon, since incoming light is
                // scattered. Specular reflections are mirror-like reflections where the
                // light reflects perfectly off of a point.

                vec3 diffuseColor = vec3(r, g, b); // Diffuse color uses color from texture
                vec3 ambientColor = diffuseColor / 7.0;
                vec3 specularColor = vec3(1.0, 1.0, 1.0);
                const float shininess = 80.0;

                // Calculate normalized normal vector and light direction vector
                vec3 norm = normalize(transformedNormal);
                vec3 light = normalize(vec3(fLightPosition - fPosition));

                // Compute diffuse reflection brightness for diffuse reflection
                float diffuse = max(dot(norm, light), 0.0);
                float specular = 0.0;
                if (diffuse > 0.0) {
                    // Compute the vector between the vertex and the viewer
                    vec3 viewer = normalize(-fPosition);
                    // Compute the halfway vector between viewer and light
                    vec3 halfway = normalize(light + viewer);
                    // Compute specular reflection brightness
                    float specAngle = max(dot(norm, halfway), 0.0);
                    // Dim specular reflection brightness by a shininess value (higher is less shiny)
                    specular = pow(specAngle, shininess);
                }

                // Apply new color as a combination of ambient, diffuse, and specular
                gl_FragColor = vec4(ambientColor + diffuse * diffuseColor + specular * specularColor, 1.0);
            }
        </script>
        <script type="text/javascript" src="../Common/webgl-utils.js"></script>
        <script type="text/javascript" src="../Common/initShaders.js"></script>
        <script type="text/javascript" src="../Common/MV.js"></script>
        <script type="text/javascript" src="../Common/MV2.js"></script>
        <script type="text/javascript" src="../Common/textures.js"></script>
        <script type="text/javascript" src="initBufferSphere.js"></script>
        <script type="text/javascript" src="gasketMod6.js"></script>
    </head>
    <body>
        <canvas id="gl-canvas">
            Sorry; your web browser does not support HTML5's canvas element.
        </canvas>
        <div id="controls">
            <p>Click and drag on the image to position the camera!</p>
            <p>Use the scroll wheel to zoom in/out (more easily visible in perspective mode).</p>
            <div class="controlsElement">
                <div id="perspectiveContainer">
                    <p>Press the button below to toggle between perspective and orthogonal projections</p>
                    <button id="perspectiveButton">Toggle view</button>
                </div>
            </div>
            <div class="controlsElement">
                <p>Depth of clipping volume</p>
                <div class="sliderContainer">
                    <p>1</p>
                    <input id="depthSlider" type="range" min="1" max="10.0" step="0.05" value="5" />
                    <p>10</p>
                </div>
            </div>
            <div class="controlsElement">
                <p>Radius (camera distance)</p>
                <div class="sliderContainer">
                    <p>2</p>
                    <input id="radiusSlider" type="range" min="2.0" max="10.0" step="0.05" value="3.0" />
                    <p>10</p>
                </div>
            </div>
            <div class="controlsElement">
                <p>Theta (horizontal angle)</p>
                <div class="sliderContainer">
                    <p>0</p>
                    <input id="thetaSlider" type="range" min="0" max="360" step="2.5" value="0" />
                    <p>360</p>
                </div>
            </div>
            <div class="controlsElement">
                <p>Phi (vertical angle)</p>
                <div class="sliderContainer">
                    <p>-90</p>
                    <input id="phiSlider" type="range" min="-90" max="90" step="2.5" value="0" />
                    <p>90</p>
                </div>
            </div>
            <div class="controlsElement">
                <p>Aspect ratio (input value : 1)</p>
                <div class="sliderContainer">
                    <p>1</p>
                    <input id="aspectSlider" type="range" min="1" max="5" step="0.05" value="1" />
                    <p>5</p>
                </div>
            </div>
        </div>
    </body>
</html>
